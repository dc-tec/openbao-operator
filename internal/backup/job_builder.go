package backup

import (
	"fmt"
	"strings"

	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/utils/ptr"

	openbaov1alpha1 "github.com/dc-tec/openbao-operator/api/v1alpha1"
	"github.com/dc-tec/openbao-operator/internal/auth"
	"github.com/dc-tec/openbao-operator/internal/constants"
	"github.com/dc-tec/openbao-operator/internal/openbao"
)

// JobType distinguishes between scheduled backups and pre-upgrade snapshots.
type JobType string

const (
	// JobTypeScheduled is a regular scheduled backup.
	JobTypeScheduled JobType = "scheduled"
	// JobTypePreUpgrade is a pre-upgrade snapshot backup.
	JobTypePreUpgrade JobType = "pre-upgrade"
)

// JobOptions configures backup job creation.
type JobOptions struct {
	// JobName is the name of the Job to create.
	JobName string
	// JobType distinguishes between scheduled and pre-upgrade backups.
	JobType JobType
	// BackupKey is the S3/object storage key for the backup.
	// Required for scheduled backups; can be empty for pre-upgrade (auto-generated by executor).
	BackupKey string
	// VerifiedExecutorDigest is the digest of a verified executor image (optional).
	// If empty, the configured or default image is used.
	VerifiedExecutorDigest string
	// FilenamePrefix is prepended to the backup filename (e.g., "pre-upgrade").
	// Only used when BackupKey is empty.
	FilenamePrefix string
	// ClientConfig holds the smart client configuration to be injected as environment variables.
	ClientConfig openbao.ClientConfig
}

// BuildJob creates a Kubernetes Job for executing a backup.
// This is the single source of truth for backup job construction, used by both
// the Backup Manager (scheduled backups) and Upgrade Manager (pre-upgrade snapshots).
func BuildJob(cluster *openbaov1alpha1.OpenBaoCluster, opts JobOptions) (*batchv1.Job, error) {
	if cluster.Spec.Backup == nil {
		return nil, fmt.Errorf("spec.backup is required for backup Jobs")
	}

	// Determine image
	image := opts.VerifiedExecutorDigest
	if image == "" {
		var err error
		image, err = GetBackupExecutorImage(cluster)
		if err != nil {
			return nil, fmt.Errorf("failed to determine backup executor image: %w", err)
		}
	}

	// Build environment variables
	env := BuildEnvVars(cluster, opts)

	// Build volumes and mounts
	volumes := BuildBackupJobVolumes(cluster)
	volumeMounts := BuildBackupJobVolumeMounts(cluster)

	// Determine backup type label
	backupType := string(opts.JobType)
	if opts.JobType == JobTypePreUpgrade {
		backupType = constants.BackupTypePreUpgrade
	}

	// Service account name
	serviceAccountName := backupServiceAccountName(cluster)

	// Job spec
	backoffLimit := int32(0)
	ttlSecondsAfterFinished := int32(backupJobTTLSeconds)

	job := &batchv1.Job{
		ObjectMeta: metav1.ObjectMeta{
			Name:      opts.JobName,
			Namespace: cluster.Namespace,
			Labels: map[string]string{
				constants.LabelAppName:           constants.LabelValueAppNameOpenBao,
				constants.LabelAppInstance:       cluster.Name,
				constants.LabelAppManagedBy:      constants.LabelValueAppManagedByOpenBaoOperator,
				constants.LabelOpenBaoCluster:    cluster.Name,
				constants.LabelOpenBaoComponent:  ComponentBackup,
				constants.LabelOpenBaoBackupType: backupType,
			},
			Annotations: map[string]string{},
		},
		Spec: batchv1.JobSpec{
			BackoffLimit:            &backoffLimit,
			TTLSecondsAfterFinished: &ttlSecondsAfterFinished,
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						constants.LabelAppName:           constants.LabelValueAppNameOpenBao,
						constants.LabelAppInstance:       cluster.Name,
						constants.LabelAppManagedBy:      constants.LabelValueAppManagedByOpenBaoOperator,
						constants.LabelOpenBaoCluster:    cluster.Name,
						constants.LabelOpenBaoComponent:  ComponentBackup,
						constants.LabelOpenBaoBackupType: backupType,
					},
				},
				Spec: corev1.PodSpec{
					ServiceAccountName:           serviceAccountName,
					AutomountServiceAccountToken: ptr.To(false),
					SecurityContext: &corev1.PodSecurityContext{
						RunAsNonRoot: ptr.To(true),
						RunAsUser:    ptr.To(constants.UserBackup),
						RunAsGroup:   ptr.To(constants.GroupBackup),
						FSGroup:      ptr.To(constants.GroupBackup),
						SeccompProfile: &corev1.SeccompProfile{
							Type: corev1.SeccompProfileTypeRuntimeDefault,
						},
					},
					RestartPolicy: corev1.RestartPolicyNever,
					Containers: []corev1.Container{
						{
							Name:  ComponentBackup,
							Image: image,
							SecurityContext: &corev1.SecurityContext{
								AllowPrivilegeEscalation: ptr.To(false),
								Capabilities: &corev1.Capabilities{
									Drop: []corev1.Capability{"ALL"},
								},
								ReadOnlyRootFilesystem: ptr.To(true),
								RunAsNonRoot:           ptr.To(true),
							},
							Resources: corev1.ResourceRequirements{
								Requests: corev1.ResourceList{
									corev1.ResourceCPU:    resource.MustParse("100m"),
									corev1.ResourceMemory: resource.MustParse("128Mi"),
								},
								Limits: corev1.ResourceList{
									corev1.ResourceCPU:    resource.MustParse("500m"),
									corev1.ResourceMemory: resource.MustParse("512Mi"),
								},
							},
							Env:          env,
							VolumeMounts: volumeMounts,
						},
					},
					Volumes: volumes,
				},
			},
		},
	}

	// Add backup key annotation for scheduled backups
	if opts.BackupKey != "" {
		job.Annotations["openbao.org/backup-key"] = opts.BackupKey
	}

	// Add AppArmor if configured
	if cluster.Spec.WorkloadHardening != nil && cluster.Spec.WorkloadHardening.AppArmorEnabled {
		job.Spec.Template.Spec.SecurityContext.AppArmorProfile = &corev1.AppArmorProfile{
			Type: corev1.AppArmorProfileTypeRuntimeDefault,
		}
	}

	return job, nil
}

// BuildEnvVars builds the environment variables for a backup job.
func BuildEnvVars(cluster *openbaov1alpha1.OpenBaoCluster, opts JobOptions) []corev1.EnvVar {
	backupCfg := cluster.Spec.Backup

	region := backupCfg.Target.Region
	if region == "" {
		region = constants.DefaultS3Region
	}

	// Compute StatefulSet name for pod discovery (Blue/Green aware)
	statefulSetName := cluster.Name
	if cluster.Status.BlueGreen != nil && cluster.Status.BlueGreen.BlueRevision != "" {
		statefulSetName = fmt.Sprintf("%s-%s", cluster.Name, cluster.Status.BlueGreen.BlueRevision)
	}

	env := []corev1.EnvVar{
		{Name: constants.EnvClusterNamespace, Value: cluster.Namespace},
		{Name: constants.EnvClusterName, Value: cluster.Name},
		{Name: constants.EnvStatefulSetName, Value: statefulSetName},
		{Name: constants.EnvClusterReplicas, Value: fmt.Sprintf("%d", cluster.Spec.Replicas)},
		{Name: constants.EnvBackupEndpoint, Value: backupCfg.Target.Endpoint},
		{Name: constants.EnvBackupBucket, Value: backupCfg.Target.Bucket},
		{Name: constants.EnvBackupPathPrefix, Value: backupCfg.Target.PathPrefix},
		{Name: constants.EnvBackupRegion, Value: region},
		{Name: constants.EnvBackupUsePathStyle, Value: fmt.Sprintf("%t", backupCfg.Target.UsePathStyle)},
	}

	// Add backup key if provided
	if opts.BackupKey != "" {
		env = append(env, corev1.EnvVar{Name: constants.EnvBackupKey, Value: opts.BackupKey})
	}

	// Add filename prefix for pre-upgrade backups (or custom prefix)
	if opts.FilenamePrefix != "" {
		env = append(env, corev1.EnvVar{Name: constants.EnvBackupFilenamePrefix, Value: opts.FilenamePrefix})
	}

	// AWS Role ARN for Web Identity (IRSA)
	if backupCfg.Target.RoleARN != "" {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvAWSRoleARN,
			Value: backupCfg.Target.RoleARN,
		})
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvAWSWebIdentityTokenFile,
			Value: awsWebIdentityTokenFile,
		})
	}

	// S3 upload configuration
	if backupCfg.Target.PartSize > 0 {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvBackupPartSize,
			Value: fmt.Sprintf("%d", backupCfg.Target.PartSize),
		})
	}
	if backupCfg.Target.Concurrency > 0 {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvBackupConcurrency,
			Value: fmt.Sprintf("%d", backupCfg.Target.Concurrency),
		})
	}

	// Credentials secret reference
	// SECURITY: Do NOT pass cross-namespace references. Secrets must be in cluster.Namespace.
	if backupCfg.Target.CredentialsSecretRef != nil {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvBackupCredentialsSecretName,
			Value: backupCfg.Target.CredentialsSecretRef.Name,
		})
	}

	// JWT Auth configuration (preferred method)
	if backupCfg.JWTAuthRole != "" {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvBackupJWTAuthRole,
			Value: backupCfg.JWTAuthRole,
		})
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvBackupAuthMethod,
			Value: constants.BackupAuthMethodJWT,
		})
	}

	// Token secret reference (fallback for token-based auth)
	// SECURITY: Do NOT pass cross-namespace references. Secrets must be in cluster.Namespace.
	if backupCfg.TokenSecretRef != nil {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvBackupTokenSecretName,
			Value: backupCfg.TokenSecretRef.Name,
		})
		// Only set auth method to token if JWT Auth is not configured
		if backupCfg.JWTAuthRole == "" {
			env = append(env, corev1.EnvVar{
				Name:  constants.EnvBackupAuthMethod,
				Value: constants.BackupAuthMethodToken,
			})
		}
	}

	// Smart Client Limits
	if opts.ClientConfig.RateLimitQPS > 0 {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvClientQPS,
			Value: fmt.Sprintf("%f", opts.ClientConfig.RateLimitQPS),
		})
	}
	if opts.ClientConfig.RateLimitBurst > 0 {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvClientBurst,
			Value: fmt.Sprintf("%d", opts.ClientConfig.RateLimitBurst),
		})
	}
	if opts.ClientConfig.CircuitBreakerFailureThreshold > 0 {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvClientCircuitBreakerFailureThreshold,
			Value: fmt.Sprintf("%d", opts.ClientConfig.CircuitBreakerFailureThreshold),
		})
	}
	if opts.ClientConfig.CircuitBreakerOpenDuration > 0 {
		env = append(env, corev1.EnvVar{
			Name:  constants.EnvClientCircuitBreakerOpenDuration,
			Value: opts.ClientConfig.CircuitBreakerOpenDuration.String(),
		})
	}

	return env
}

// BuildBackupJobVolumeMounts builds the volume mounts for a backup job.
func BuildBackupJobVolumeMounts(cluster *openbaov1alpha1.OpenBaoCluster) []corev1.VolumeMount {
	mounts := []corev1.VolumeMount{}

	// Mount TLS CA certificate
	mounts = append(mounts, corev1.VolumeMount{
		Name:      backupTLSCAVolumeName,
		MountPath: constants.PathTLS,
		ReadOnly:  true,
	})

	if cluster.Spec.Backup.Target.RoleARN != "" {
		mounts = append(mounts, corev1.VolumeMount{
			Name:      awsWebIdentityVolumeName,
			MountPath: awsWebIdentityMountPath,
			ReadOnly:  true,
		})
	}

	// Mount credentials secret if provided
	if cluster.Spec.Backup.Target.CredentialsSecretRef != nil {
		mounts = append(mounts, corev1.VolumeMount{
			Name:      backupCredentialsVolumeName,
			MountPath: backupCredentialsMountPath,
			ReadOnly:  true,
		})
	}

	// Mount JWT token from projected volume (preferred method)
	if cluster.Spec.Backup.JWTAuthRole != "" {
		mounts = append(mounts, corev1.VolumeMount{
			Name:      openBaoTokenVolumeName,
			MountPath: openBaoTokenMountPath,
			ReadOnly:  true,
		})
	}

	// Mount token secret if provided (fallback method when JWT Auth is not used)
	if cluster.Spec.Backup.TokenSecretRef != nil {
		mounts = append(mounts, corev1.VolumeMount{
			Name:      backupTokenVolumeName,
			MountPath: backupTokenMountPath,
			ReadOnly:  true,
		})
	}

	return mounts
}

// BuildBackupJobVolumes builds the volumes for a backup job.
func BuildBackupJobVolumes(cluster *openbaov1alpha1.OpenBaoCluster) []corev1.Volume {
	volumes := []corev1.Volume{}

	// TLS CA certificate
	volumes = append(volumes, corev1.Volume{
		Name: backupTLSCAVolumeName,
		VolumeSource: corev1.VolumeSource{
			Secret: &corev1.SecretVolumeSource{
				SecretName: cluster.Name + constants.SuffixTLSCA,
			},
		},
	})

	if cluster.Spec.Backup.Target.RoleARN != "" {
		volumes = append(volumes, corev1.Volume{
			Name: awsWebIdentityVolumeName,
			VolumeSource: corev1.VolumeSource{
				Projected: &corev1.ProjectedVolumeSource{
					Sources: []corev1.VolumeProjection{
						{
							ServiceAccountToken: &corev1.ServiceAccountTokenProjection{
								Path:              "token",
								ExpirationSeconds: ptr.To(int64(3600)),
								Audience:          awsWebIdentityTokenAudience,
							},
						},
					},
				},
			},
		})
	}

	// Credentials secret if provided
	if cluster.Spec.Backup.Target.CredentialsSecretRef != nil {
		secretName := cluster.Spec.Backup.Target.CredentialsSecretRef.Name
		credentialsFileMode := int32(0400)

		volumes = append(volumes, corev1.Volume{
			Name: backupCredentialsVolumeName,
			VolumeSource: corev1.VolumeSource{
				Secret: &corev1.SecretVolumeSource{
					SecretName:  secretName,
					DefaultMode: &credentialsFileMode,
				},
			},
		})
	}

	// JWT token from projected volume (preferred method)
	if cluster.Spec.Backup.JWTAuthRole != "" {
		audience := auth.OpenBaoJWTAudience()
		volumes = append(volumes, corev1.Volume{
			Name: openBaoTokenVolumeName,
			VolumeSource: corev1.VolumeSource{
				Projected: &corev1.ProjectedVolumeSource{
					Sources: []corev1.VolumeProjection{
						{
							ServiceAccountToken: &corev1.ServiceAccountTokenProjection{
								Path:              openBaoTokenFileRelativePath,
								ExpirationSeconds: ptr.To(int64(3600)),
								Audience:          audience,
							},
						},
					},
				},
			},
		})
	}

	// Token secret (fallback method when JWT Auth is not used)
	if cluster.Spec.Backup.TokenSecretRef != nil {
		secretName := cluster.Spec.Backup.TokenSecretRef.Name
		tokenFileMode := int32(0400)
		volumes = append(volumes, corev1.Volume{
			Name: backupTokenVolumeName,
			VolumeSource: corev1.VolumeSource{
				Secret: &corev1.SecretVolumeSource{
					SecretName:  secretName,
					DefaultMode: &tokenFileMode,
				},
			},
		})
	}

	return volumes
}

// GetBackupExecutorImage returns the backup executor image to use.
// If not specified in the cluster spec, returns the default image derived from
// OPERATOR_BACKUP_IMAGE_REPOSITORY and OPERATOR_VERSION environment variables.
func GetBackupExecutorImage(cluster *openbaov1alpha1.OpenBaoCluster) (string, error) {
	if cluster.Spec.Backup != nil && strings.TrimSpace(cluster.Spec.Backup.ExecutorImage) != "" {
		return cluster.Spec.Backup.ExecutorImage, nil
	}
	return constants.DefaultBackupImage()
}
